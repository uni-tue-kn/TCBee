use std::error::Error;

use anyhow::Context;
use aya::{
    maps::{PerCpuArray, PerCpuHashMap, RingBuf},
    programs::{tc, FEntry, FExit, SchedClassifier, TcAttachType, TracePoint, Xdp, XdpFlags},
    Btf, Ebpf,
};
use log::{debug, info, warn};
use tcbee_common::bindings::{
    flow::IpTuple, tcp_bad_csum::tcp_bad_csum_entry, tcp_header::tcp_packet_trace, tcp_probe::tcp_probe_entry, tcp_retransmit_synack::tcp_retransmit_synack_entry, tcp_sock::sock_trace_entry, EBPFTracePointType
};
use tokio::task::{self, spawn_blocking, JoinHandle};
use tokio_util::sync::CancellationToken;

use crate::{
    handlers::{tracepoints::HandlerConstraints, BufferHandler, BufferHandlerImpl},
    viz::ebpf_watcher::EBPFWatcher,
};

use super::errors::EBPFRunnerError;

// TODO: how to handle multiple tracepoints at the same time?
pub struct eBPFRunner {
    stop_token: CancellationToken,
    threads: Vec<JoinHandle<()>>,
    iface: String,
    do_tui: bool,
    ebpf: Option<Ebpf>,
}

impl eBPFRunner {
    // Load eBPF program and setup references
    // Code generated by Aya template
    pub fn new(
        iface: String,
        stop_token: CancellationToken,
        do_tui: bool,
    ) -> Result<Self, Box<dyn Error>> {
        Ok(eBPFRunner {
            stop_token: stop_token,
            // TODO: new with capacity?
            threads: Vec::new(),
            iface: iface,
            do_tui: do_tui,
            ebpf: None,
        })
    }

    pub async fn stop(self) -> () {
        // Signal child threads to stop
        self.stop_token.cancel();

        // Wait for threads to finish
        for t in self.threads {
            let _ = t.await;
        }
    }

    fn add_tcp_sock_tracer(
        &mut self,
        ebpf: &mut Ebpf,
        token: CancellationToken,
    ) -> Result<(), Box<dyn Error>> {
        let btf = Btf::from_sys_fs().context("BTF from sysfs")?;
        let program: &mut FEntry = ebpf.program_mut("sock_sendmsg").unwrap().try_into()?;
        program.load("tcp_sendmsg", &btf)?;
        program.attach()?;

        let btf = Btf::from_sys_fs().context("BTF from sysfs")?;
        let program2: &mut FEntry = ebpf.program_mut("sock_recvmsg").unwrap().try_into()?;
        program2.load("tcp_recvmsg", &btf)?;
        program2.attach()?;

        // Start SOCK_SEND handling
        // Get queue from
        let map =
            ebpf.take_map("TCP_SEND_SOCK_EVENTS")
                .ok_or(EBPFRunnerError::QueueNotFoundError {
                    name: "TCP_SEND_SOCK_EVENTS".to_string(),
                    trace: "Socket Tracer tcp_sendmsg".to_string(),
                })?;

        let buff: RingBuf<aya::maps::MapData> = RingBuf::try_from(map)?;

        // Create handler object
        let mut handler: BufferHandler<sock_trace_entry> =
            BufferHandler::<sock_trace_entry>::new("TCP_SEND_SOCK_EVENTS", token.clone(), buff,"/tmp/sock_send.tcp".to_string()).unwrap();

        // Start thread and store join handle
        let thread: JoinHandle<()> = task::spawn(async move {
            handler.run().await;
        });

        // Store join handle to wait for threads to finish on quit
        self.threads.push(thread);

        // Start SOCK_RECV handling
        // Get queue from
        let map =
            ebpf.take_map("TCP_RECV_SOCK_EVENTS")
                .ok_or(EBPFRunnerError::QueueNotFoundError {
                    name: "TCP_RECV_SOCK_EVENTS".to_string(),
                    trace: "Socket Tracer tcp_recvmsg".to_string(),
                })?;

        let buff: RingBuf<aya::maps::MapData> = RingBuf::try_from(map)?;

        // Create handler object
        let mut handler: BufferHandler<sock_trace_entry> =
            BufferHandler::<sock_trace_entry>::new("TCP_RECV_SOCK_EVENTS", token, buff,"/tmp/sock_recv.tcp".to_string()).unwrap();

        // Start thread and store join handle
        let thread: JoinHandle<()> = task::spawn(async move {
            handler.run().await;
        });

        // Store join handle to wait for threads to finish on quit
        self.threads.push(thread);


        Ok(())
    }

    // TODO: add possibility for multiple interfaces?
    fn add_xdp_tracer(
        &mut self,
        ebpf: &mut Ebpf,
        interface: String,
        token: CancellationToken,
        file_path: String,
    ) -> Result<(), Box<dyn Error>> {
        // Get tracepoint name
        let name = "xdp_packet_tracer";

        // Get XDP object from eBPF library
        let tracer: &mut Xdp = ebpf
            .program_mut(name)
            .ok_or(EBPFRunnerError::InvalidProgramError {
                name: name.to_string(),
            })?
            .try_into()?;

        // Load and attach tracepoint to kernel
        tracer.load()?;
        tracer.attach(&interface, XdpFlags::default())?;

        // Start handling function
        // Get queue from
        let map =
            ebpf.take_map("TCP_PACKETS_INGRESS")
                .ok_or(EBPFRunnerError::QueueNotFoundError {
                    name: "TCP_PACKETS_INGRESS".to_string(),
                    trace: "XDP Packet Tracer".to_string(),
                })?;

        let buff: RingBuf<aya::maps::MapData> = RingBuf::try_from(map)?;

        // Create handler object
        // TODO: handling of None!
        let mut handler: BufferHandler<tcp_packet_trace> =
            BufferHandler::<tcp_packet_trace>::new(name, token, buff, file_path).unwrap();

        // Start thread and store join handle
        let thread: JoinHandle<()> = task::spawn(async move {
            handler.run().await;
        });

        // Store join handle to wait for threads to finish on quit
        self.threads.push(thread);

        Ok(())
    }

    fn add_tc_tracer(
        &mut self,
        ebpf: &mut Ebpf,
        interface: String,
        token: CancellationToken,
        file_path: String,
    ) -> Result<(), Box<dyn Error>> {
        let name = "tc_packet_tracer";

        // Needs to be called before a TC can be attached to a program!
        // Error supressed because if this fails it may be a false positive "file exists"
        // The next call will fail either way if this fails due to any other reason!
        //
        let _ = tc::qdisc_add_clsact(&interface);

        // Attach eBPF TC to Egress
        let tracer: &mut SchedClassifier = ebpf
            .program_mut(name)
            .ok_or(EBPFRunnerError::InvalidProgramError {
                name: name.to_string(),
            })?
            .try_into()?;

        // Load and attach tracepoint to kernel
        tracer.load()?;
        tracer.attach(&interface, TcAttachType::Egress)?;

        // Start handling function
        // Get queue from
        let map =
            ebpf.take_map("TCP_PACKETS_EGRESS")
                .ok_or(EBPFRunnerError::QueueNotFoundError {
                    name: "TCP_PACKETS_EGRESS".to_string(),
                    trace: "TC Packet Tracer".to_string(),
                })?;

        let buff: RingBuf<aya::maps::MapData> = RingBuf::try_from(map)?;

        // Create handler object
        // TODO: handling of None!
        let mut handler: BufferHandler<tcp_packet_trace> =
            BufferHandler::<tcp_packet_trace>::new(name, token, buff, file_path).unwrap();

        // Start thread and store join handle
        let thread: JoinHandle<()> = task::spawn(async move {
            handler.run().await;
        });

        // Store join handle to wait for threads to finish on quit
        self.threads.push(thread);

        Ok(())
    }

    // The BufferHandlerImpl trait is used to implement the unique handling function for T.
    fn add_tracepoint<T: HandlerConstraints<T>>(
        &mut self, // The
        ebpf: &mut Ebpf,
        token: CancellationToken,
        file_path: String,
    ) -> Result<(), Box<dyn Error>>
    where
        // BufferHandlerImpl has to be implemented for BufferHandler for the passed T
        BufferHandler<T>: BufferHandlerImpl<T>,
    {
        // Get tracepoint name
        let name = T::NAME;

        // Get trace point object from eBPF library
        let trace_point: &mut TracePoint = ebpf
            .program_mut(name)
            .ok_or(EBPFRunnerError::InvalidProgramError {
                name: name.to_string(),
            })?
            .try_into()?;

        // Load and attach tracepoint to kernel
        trace_point.load()?;
        trace_point.attach(T::CATEGORY, name)?;

        // Get queue from
        let map = ebpf
            .take_map(T::QUEUE_NAME)
            .ok_or(EBPFRunnerError::QueueNotFoundError {
                name: T::QUEUE_NAME.to_string(),
                trace: T::NAME.to_string(),
            })?;

        let buff: RingBuf<aya::maps::MapData> = RingBuf::try_from(map)?;

        // Create handler object
        let mut handler = BufferHandler::<T>::new(name, token, buff, file_path).unwrap();

        // Start thread and store join handle
        let thread: JoinHandle<()> = task::spawn(async move {
            handler.run().await;
        });

        // Store join handle to wait for threads to finish on quit
        self.threads.push(thread);

        // Return ebpf mapping
        Ok(())
    }

    pub async fn run(&mut self) -> Result<(), Box<dyn Error>> {
        // ###########################
        // SETUP
        // ###########################

        env_logger::init();

        // Bump the memlock rlimit. This is needed for older kernels that don't use the
        // new memcg based accounting, see https://lwn.net/Articles/837122/
        let rlim = libc::rlimit {
            rlim_cur: libc::RLIM_INFINITY,
            rlim_max: libc::RLIM_INFINITY,
        };
        let ret = unsafe { libc::setrlimit(libc::RLIMIT_MEMLOCK, &rlim) };
        if ret != 0 {
            debug!("remove limit on locked memory failed, ret is: {}", ret);
        }

        // This will include your eBPF object file as raw bytes at compile-time and load it at
        // runtime. This approach is recommended for most real-world use cases. If you would
        // like to specify the eBPF program at runtime rather than at compile-time, you can
        // reach for `Bpf::load_file` instead.
        let mut ebpf = aya::Ebpf::load(aya::include_bytes_aligned!(concat!(
            env!("OUT_DIR"),
            "/tcbee"
        )))?;

        if let Err(e) = aya_log::EbpfLogger::init(&mut ebpf) {
            // This can happen if you remove all log statements from your eBPF program.
            warn!("failed to initialize eBPF logger: {}", e);
        }

        // ###########################
        // RUNNING
        // ###########################
        info!("Starting eBPF probes!");

        self.add_tc_tracer(
            &mut ebpf,
            self.iface.clone(),
            self.stop_token.child_token(),
            "/tmp/tc.tcp".to_string(),
        )
        .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
            name: "TC TRACER".to_string(),
            orig_e: e,
        })?;

        // TODO: pass reference to string to remove clone()
        self.add_xdp_tracer(
            &mut ebpf,
            self.iface.clone(),
            self.stop_token.child_token(),
            "/tmp/xdp.tcp".to_string(),
        )
        .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
            name: "XDP TRACER".to_string(),
            orig_e: e,
        })?;

        // Loads program associated into kernel
        // TODO: move this to another module to select which tracepoints are active
        // TODO: Derive paths to files from passed event struct

        self.add_tracepoint::<tcp_probe_entry>(
            &mut ebpf,
            self.stop_token.child_token(),
            "/tmp/probe.tcp".to_string(),
        )
        .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
            name: tcp_probe_entry::NAME.to_string(),
            orig_e: e,
        })?;

        self.add_tracepoint::<tcp_retransmit_synack_entry>(
            &mut ebpf,
            self.stop_token.child_token(),
            "/tmp/retrans_synack.tcp".to_string(),
        )
        .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
            name: tcp_retransmit_synack_entry::NAME.to_string(),
            orig_e: e,
        })?;

        self.add_tracepoint::<tcp_bad_csum_entry>(
            &mut ebpf,
            self.stop_token.child_token(),
            "/tmp/bad_csum.tcp".to_string(),
        )
        .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
            name: tcp_bad_csum_entry::NAME.to_string(),
            orig_e: e,
        })?;

        self.add_tcp_sock_tracer(&mut ebpf, self.stop_token.child_token())
            .map_err(|e| EBPFRunnerError::TracepointKernelLoadError {
                name: "TCP SOCKET TRACER".to_string(),
                orig_e: e,
            })?;

        info!("Finished loading tracepoints, starting processing!");

        // START UI
        // Load map that counts event drops
        let events_drops: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("EVENTS_DROPPED").unwrap())?;
        let events_handled: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("EVENTS_HANDLED").unwrap())?;
        let ingress_counter: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("INGRESS_EVENTS").unwrap())?;
        let egress_counter: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("EGRESS_EVENTS").unwrap())?;
        let tcp_sock_send: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("SEND_TCP_SOCK").unwrap())?;
        let tcp_sock_recv: PerCpuArray<aya::maps::MapData, u32> =
            PerCpuArray::try_from(ebpf.take_map("RECV_TCP_SOCK").unwrap())?;
        let flows_map: PerCpuHashMap<aya::maps::MapData, IpTuple, IpTuple> =
            PerCpuHashMap::try_from(ebpf.take_map("FLOWS").unwrap())?;
        // Start watcher thread
        // Stop token is cloned such that cancellation affects all other threads
        let mut watcher = EBPFWatcher::new(
            events_drops,
            events_handled,
            ingress_counter,
            egress_counter,
            tcp_sock_send,
            tcp_sock_recv,
            flows_map,
            self.stop_token.clone(),
            self.do_tui,
        )?; // Start thread and store join handle
        let watcher_thread: JoinHandle<()>;
        if self.do_tui {
            watcher_thread = spawn_blocking(move || {
                watcher.run();
            });
        } else {
            watcher_thread = spawn_blocking(move || {
                watcher.run_no_tui();
            });
        }
        self.threads.push(watcher_thread);

        // Store ebpf to ensure that it is not dropped after this function finishes!
        self.ebpf = Some(ebpf);

        // Yield to let created tasks work
        task::yield_now().await;

        // Check every few ms if token should be cancelled
        // TODO: make this better
        Ok(())
    }
}
